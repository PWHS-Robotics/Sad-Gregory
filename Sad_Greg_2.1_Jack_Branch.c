#pragma config(Sensor, in1,    BatteryStatus,  sensorAnalog)
#pragma config(Motor,  port2,           HvyL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           HvyR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ld,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rd,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           fla,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           bla,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           bra,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           fra,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// VEX Competition Stuff
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

task SuperWin()
{
	playSoundFile("Super (1).wav");
	return;
}

task HallOfMountainKing()
{
	playTone(220,12);  wait1Msec(150);
	playTone(247,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(294,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(330,24);  wait1Msec(300);
	playTone(311,12);  wait1Msec(150);
	playTone(247,12);  wait1Msec(150);
	playTone(311,24);  wait1Msec(300);
	playTone(294,12);  wait1Msec(150);
	playTone(233,12);  wait1Msec(150);
	playTone(294,24);  wait1Msec(300);
	playTone(220,12);  wait1Msec(150);
	playTone(247,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(294,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(392,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(392,48);  wait1Msec(600);
	                   wait1Msec(80);
	playTone(220,12);  wait1Msec(150);
	playTone(247,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(294,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(330,24);  wait1Msec(300);
	playTone(311,12);  wait1Msec(150);
	playTone(247,12);  wait1Msec(150);
	playTone(311,24);  wait1Msec(300);
	playTone(294,12);  wait1Msec(150);
	playTone(233,12);  wait1Msec(150);
	playTone(294,24);  wait1Msec(300);
	playTone(220,12);  wait1Msec(150);
	playTone(247,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(294,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(392,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(262,12);  wait1Msec(150);
	playTone(330,12);  wait1Msec(150);
	playTone(392,48);  wait1Msec(600);
	                   wait1Msec(80);
	playTone(330,12);  wait1Msec(150);
	playTone(370,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(494,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(494,24);  wait1Msec(300);
	playTone(523,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(523,24);  wait1Msec(300);
	playTone(494,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(494,24);  wait1Msec(300);
	playTone(330,12);  wait1Msec(150);
	playTone(370,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(494,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(494,24);  wait1Msec(300);
	playTone(523,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(523,24);  wait1Msec(300);
	playTone(494,48);  wait1Msec(600);
	                   wait1Msec(80);
	playTone(330,12);  wait1Msec(150);
	playTone(370,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(494,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(494,24);  wait1Msec(300);
	playTone(523,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(523,24);  wait1Msec(300);
	playTone(494,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(494,24);  wait1Msec(300);
	playTone(330,12);  wait1Msec(150);
	playTone(370,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(494,12);  wait1Msec(150);
	playTone(415,12);  wait1Msec(150);
	playTone(494,24);  wait1Msec(300);
	playTone(523,12);  wait1Msec(150);
	playTone(440,12);  wait1Msec(150);
	playTone(523,24);  wait1Msec(300);
	playTone(494,48);  wait1Msec(600);
	                   wait1Msec(16);
	playTone(440,8);   wait1Msec(150);
	playTone(494,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(587,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(659,24);  wait1Msec(300);
	playTone(622,8);   wait1Msec(150);
	playTone(494,8);   wait1Msec(150);
	playTone(622,24);  wait1Msec(300);
	playTone(587,8);   wait1Msec(150);
	playTone(466,8);   wait1Msec(150);
	playTone(587,24);  wait1Msec(300);
	playTone(440,8);   wait1Msec(150);
	playTone(494,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(587,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(880,8);   wait1Msec(150);
	playTone(784,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(784,48);  wait1Msec(600);
	                   wait1Msec(8);
	playTone(440,8);   wait1Msec(150);
	playTone(494,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(587,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(659,24);  wait1Msec(300);
	playTone(622,8);   wait1Msec(150);
	playTone(494,8);   wait1Msec(150);
	playTone(622,24);  wait1Msec(300);
	playTone(587,8);   wait1Msec(150);
	playTone(466,8);   wait1Msec(150);
	playTone(587,24);  wait1Msec(300);
	playTone(440,8);   wait1Msec(150);
	playTone(494,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(587,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(523,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(880,8);   wait1Msec(150);
	playTone(831,8);   wait1Msec(150);
	playTone(659,8);   wait1Msec(150);
	playTone(831,8);   wait1Msec(150);
	playTone(988,8);   wait1Msec(150);
	playTone(880,48);  wait1Msec(600);
	return;
}

// Player2 defines
#define Joy2LX -vexRT[Ch4Xmtr2]
#define Joy2LY  vexRT[Ch3Xmtr2]
#define Joy2RX  vexRT[Ch1Xmtr2]
#define Joy2RY  vexRT[Ch2Xmtr2]

// Music
#define MtnKingOn  vexRT[Btn7LXmtr2]
#define MtnKingOff vexRT[Btn7DXmtr2]
#define MerioOn  vexRT[Btn7UXmtr2]
#define MerioOff vexRT[Btn7RXmtr2]

// Hands
#define HvyLU	vexRT[Btn5UXmtr2]
#define HvyLD	vexRT[Btn5DXmtr2]
#define HvyRU	vexRT[Btn6UXmtr2]
#define HvyRD vexRT[Btn6DXmtr2]

#define HvyHoldConst 10
#define HvyUpConst 120
#define HvyDnConst -50

// Arm
#define ArmOff vexRT[Btn8DXmtr2]

#define ArmHoldConst 20
#define ClawDnSens 0.3
#define ClawUpSens 0.8


task Player2()
{
	while(true)
	{
		// Arm
		float sens = ArmOff ? 0 : Joy2LY > 0 ? ClawUpSens : ClawDnSens;
		float hold = ArmOff ? 0 : ArmHoldConst;

		motor[fla] = (Joy2LY * .7 * sens) + hold;
		motor[bla] = (Joy2LY * .7 * sens) + hold;
		motor[fra] = (Joy2LY * sens) + hold;
		motor[bra] = (Joy2LY * sens) + hold;

		motor[claw] = Joy2RY + 10;

		// Hands
		if (HvyLU)
			motor[HvyL] = HvyUpConst;
		else if (HvyLD)
			motor[HvyL] = HvyDnConst;
		else
			motor[HvyL] = HvyHoldConst;

		if (HvyRU)
			motor[HvyR] = HvyUpConst;
		else if(HvyRD)
			motor[HvyR] = HvyDnConst;
		else
			motor[HvyR] = HvyHoldConst;

		// Sound
		if(MtnKingOn)
			startTask(HallOfMountainKing);
		if(MtnKingOff)
			stopTask(HallOfMountainKing);
		if(MerioOn)
			startTask(SuperWin);
		if(MerioOff)
			clearSounds();
	}
}

// LCD defines
#define nPages 3

#define BtnL 0b001
#define BtnC 0b010
#define BtnR 0b100

task LCD()
{
	bLCDBacklight = true;
	string line1, line2;
	short page = 0;
	short btnFlag = 0b000;

	while(true)
	{
		// This whole thing is spaghetti
		// All it does is increment the page number with the LCD buttons
		if((nLCDButtons & BtnL) && !(btnFlag & BtnL))
		{
			page--;
			btnFlag |= BtnL;
		}
		if((nLCDButtons & BtnR) && !(btnFlag & BtnR))
		{
			page++;
			btnFlag |= BtnR;
		}
		if(page >= nPages)
			page = 0;
		if(page < 0)
			page = nPages-1;
		btnFlag &= nLCDButtons;
		// </spaghetti>

		clearLCDLine(0);
		clearLCDLine(1);

		switch(page)
		{
		case 0:
			sprintf(line1, "  Sad  Gregory  ");
			sprintf(line2, " West High 2018 ");
			break;
		case 1:
			sprintf(line1, "Primary:  %1.2fV", nImmediateBatteryLevel/1000.0);
			sprintf(line2, "Secondary:%1.2f?", (float)SensorValue[BatteryStatus]/1000.0);
			break;
		case 2:
			sprintf(line1, "Backup:   %1.2fV", BackupBatteryLevel/1000.0);
			sprintf(line2, "                ");
			break;
		default:
			sprintf(line1, "Error: Page %i  ");
			sprintf(line2, "Does Not Exist  ");
		}

		displayLCDString(0, 0, line1);
		displayLCDString(1, 0, line2);

		wait1Msec(100);
	}
}



/*--------------------------------------------------------------------------*/
/*                         Pre-Autonomous Functions                         */
/*                                                                          */
/*  You must return from this function or the autonomous and usercontrol    */
/*  tasks will not be started. This function is only called once after the  */
/*  cortex has been powered on and not every time that the robot is         */
/*  disabled.                                                               */
/*--------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// to be used by the competition include file.
	bDisplayCompetitionStatusOnLcd = false;
	startTask(LCD);
}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*---------------------------------------------------------------------------*/

// Defines because lazy
#define DriveMotors \
motor[rd] = \
motor[ld]
#define LeftDriveMotors  motor[ld]
#define RightDriveMotors motor[rd]
#define ArmMotors \
motor[fla] = \
motor[bla] = \
motor[fra] = \
motor[bra]

void fwd(int x)
{
	motor[claw] = 5;
	ArmMotors = 20;
	DriveMotors = 100;
	wait1Msec(x);
}
void bwd(int x)
{
	motor[claw] = 5;
	ArmMotors = ArmHoldConst;
	DriveMotors = -100;
	wait1Msec(x);
}
void left(int x)
{
	motor[claw] = 5;
	ArmMotors = ArmHoldConst;
	LeftDriveMotors = -100;
	RightDriveMotors = 100;
	wait1Msec(x);
}
void openClaw(int x)
{
	motor[claw] = -127;
	ArmMotors = ArmHoldConst;
	DriveMotors = 0;
	wait1Msec(x);
}
void closeClaw(int x)
{
	motor[claw] = 127;
	ArmMotors = ArmHoldConst;
	DriveMotors = 0;
	wait1Msec(x);
}
void raiseArm(int x)
{
	motor[claw] = 5;
	ArmMotors = 127;
	DriveMotors = 0;
	wait1Msec(x);
}
void lowerArm(int x)
{
	motor[claw] = 5;
	ArmMotors = -10;
	DriveMotors = 0;
	wait1Msec(x);
}

task autonomous()
{
	fwd(100);

	closeClaw(1000);
	raiseArm(3000);
	fwd(1000);

	bwd(500);
	lowerArm(1000);
	openClaw(1000);
	closeClaw(500);
	lowerArm(1500);
	bwd(1000);

	left(2000);
	fwd(2500);
}

/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*---------------------------------------------------------------------------*/

#define JoyLX -vexRT[Ch4]
#define JoyLY  vexRT[Ch3]
#define JoyRX  vexRT[Ch1]
#define JoyRY  vexRT[Ch2]
// Conrol scheme toggle button
#define BtnCtrl vexRT[Btn6U]

task usercontrol()
{
	// Might want to check if LCD task is already running
	startTask(LCD);

	startTask(Player2);

	// Conrol scheme flags
	bool altCtrl = false;
	bool ctrlCheck = false;

	while (true)
	{
		// Toggle control scheme
		if(BtnCtrl && !ctrlCheck)
		{
			altCtrl = !altCtrl;
			ctrlCheck = true;
		}
		if(!BtnCtrl)
			ctrlCheck = false;


		if(altCtrl)
		{
			// Car Drive
			motor[ld] = JoyLY + JoyRX;
			motor[rd] = JoyLY - JoyRX;
		}
		else
		{
			// Tank Drive
			motor[rd] = JoyRY;
			motor[ld] = JoyLY;
		}
	}
}
